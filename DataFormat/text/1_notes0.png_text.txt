图的存储相关知识补充我们在数据结构课上已经学习了使用指针维护链表对图进行存储。但是考虑到指针写法的复杂性,且同学们在使用指针时也更容易写错或是让程序难以调试;因此这种写法并不是十分适合在算法中使用,本文将对一些常用的图存储方法进行补充。考虑到篇幅限制,本文将仅仅介绍在算法中最常用的几种建图方法。对于更多的图存储方法。大家可以自行查阅资料进行学习。邻接矩阵对于-个有 n 个点的图,我们可以使用一个 g[n] [n]的数组来存边。若 g[u][V]二 1 则表示存在一条从点 U 到点 U 的边若为 0则表示不存在。对于带权的图。我们也可以直接用9 [u] [v]表示 U 到 U 的边的边权。对于邻接矩阵,我们能够以 0(1)的时间复杂度查找是否存在某条边2以O(n)的时间遍历一个点的所有出边但是对于邻接矩阵而言最大的问题是它在稀疏图上的效率很低,尤其是在点数较多的情况下。例如一个有 105 个点的图,我们需要开一个 9[100000] [100000] 的数组,对于我们一般的算法问题而言。这种空间开销显然是不可接受的。对于 accoding 上最常见设置的空间上限为64Mint 类型的大小为48因此我们最多能够存储64M48二16*1024*1024int 类型的数也即大约16 .106  个 inte0因此对于邻接矩阵,我们能接受的 n 的数量级大约为 103通常可以在 Floyd 算法 (时间复杂度 O(n3 ) 求得任意两点间的最小距离)中使用。CPD1 /可存储 N个点的邻接矩阵int9 [N] [N] ;11  添加一条 U  到 V 的边这条边的权值为W9 [u] [V]二W;1 遍历点 U 的出边for(int1二0;1< N;1++){if (9[u] [1]){1 do something