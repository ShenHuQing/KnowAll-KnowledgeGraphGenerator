1 dfs  遍历图intVis [N] ;11  表示一个点是否被 Visit 过VoiddfsintU){i(Vis [4] )return;Vis [u]二1;for(int1二0;1<N;1++){if (9 [u] [1]){dfs(i);邻接表由于邻接矩阵在稀疏图中花费了大量的无用空间表示不存在的边,我们考虑对其进行优化。我们使用可以动态增加元素的数据结构来维护,例如使用 c++ stl 中提供的 vector,我们可以使用Vectorcint> 9[n]来存储有 n 个点的图或者很熟悉 ctt stl 已经大量使用 vector 的同学可能会使用二维Vectorcvectorcint>>g(n)来初始化一个有 n 个点的邻接表。无论哪种方式。此时我们的  g[u]是一个 vector,其中存储了点 U 的出边。1 可存储 N  个点的邻接表CPDVectorcint>9 [N] ;11  添加一条从 U 到 V 的边11  对一个 vector 使用 push_back 方法向其末尾加入一个数 V9[u] . push_back (v) ;1 1遍历点 U的出边(int1二0;1<9 [u]Size() ;1++){intV二9 [u] [1];1 1V即是我们指向的那个点1 1do something1 1dfs  遍历图intVis [N] ;1 1表示一个点是否被 Visit 过Voiddfs (intU){i(Vis [u] )return;Vis [u]二1;for(int1二0;1<9 [u]Size() ;1++){dfs (g [u] [辽]) ;for