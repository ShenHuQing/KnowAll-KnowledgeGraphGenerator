11  在 Ctt11中已支持更加现代化的写法来遍历-个 vector,大家可能在 java中1 1已经使用过类似的写法1 例如 g[u]三{2,3,5},则 V 会直接依次遍历  2,3,5for(intV9[u] ){dfs (V);1 如果除了想要存储边;还希望存储边权;我们可以使用struct 或者 stl 的1  /array   进行存储;下面以struct 为例 (相信会使用1 array  的同学肯定也看得懂 struct 的写法)StructEdgeintto;11  表示这条边指向的点intweight;11  表示这条边的边权};VectorcEdge>9 [N] ;11  添加一条从 U 到 V 权值为 W 的边9 [u] . push_back ( {V,W} ) ;1 /遍历点 u 的出边for(int1二0;1<9[u]Size();1+)intt0?9 [u] [1]t0,weight三9[u] [1]weight;1 do something该方法存各种图都比较适合;除了有特殊需求 (例如想要0(1)的查找是否有一条边时,可以使用邻接矩阵) 的情况下,大部分问题都可以使用该方法进行建图该方法也十分地简单好写,非常推荐大家学习使用该方法!链式前向星该方法本质上是一个链表维护的邻接表,只是使用数组进行模拟c首先给出一个指针的写法,便于大家后续的理解CPPstruct Edge{int1 /表示本条边指向的点StructEdge*nxt;11  表示本条边的下一条边。/1 head [u] 表示点U指出的第一条边;对应上述邻接表中的 9[u]  这个Vector 的/1 第一个元素 (或者可以说最后一个元素)StructEdge*head [N] ;pairpairto;