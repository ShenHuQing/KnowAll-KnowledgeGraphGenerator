观察递归调用运行#间#include<stdio.h>it main0)#Include<timeh>思考double X;long fib(int ])itn;如果TLE。有没有改进办法?for(n=35;1<46;1++)return n<=1 ? 1 : fib(n-1)+fib(n-2);X=clock0;printf("Fib %od is %old in" ,1,fib());要在程序里统计时间,调用库函数clockPrintf(" OfsIn" ,(clockO-X)ICLOCKS_PER_SEC);timeh )使用下面的表达式:C:lUserslloganlDesktopl2021CSIcS-codeslrecursiveFunclfibRecTi..8Fi  36is 24157817i0.091000sFi  37 is 39088169i0.1330005clockOICLOCKS_PER_SEC, 这个表达式得Fib  38is 63245986-0.230000sFi 39 is 102334155 in0360000sreturn 0;Fi  40 is 165580141 i0.581000s到的就是从程序开始执行到该表达式求值Fi 41 is 267914296 i0.9370005Fi  42 is 433494437 i 1.559000sFi  43 is 701408733 i 2.5800005的时间间隔。以秒计数Fi  44 is 1134903170 in 4.2050005Fi  45 is 1836311903 i 6.4280005f(0)=1f1(1)=1f(2)=2Process exited after 17.32 seconds withreturn value请按任意键继续: